// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: users.sql

package model

import (
	"context"
)

const cleanUpUsers = `-- name: CleanUpUsers :execrows
DELETE FROM users
 WHERE deleted_at IS NOT NULL
`

func (q *Queries) CleanUpUsers(ctx context.Context) (int64, error) {
	result, err := q.db.Exec(ctx, cleanUpUsers)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    password, first_name, last_name, role, email
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id
`

type CreateUserParams struct {
	Password  []byte `json:"password"`
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Role      Role   `json:"role"`
	Email     string `json:"email"`
}

func (q *Queries) CreateUser(ctx context.Context, arg *CreateUserParams) (int32, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Password,
		arg.FirstName,
		arg.LastName,
		arg.Role,
		arg.Email,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteUser = `-- name: DeleteUser :execrows
UPDATE users
   SET deleted_at = CURRENT_TIMESTAMP
 WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.Exec(ctx, deleteUser, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getUserAuth = `-- name: GetUserAuth :one
SELECT id, email, password FROM users
 WHERE email = $1
   AND deleted_at IS NULl
`

type GetUserAuthRow struct {
	ID       int32  `json:"id"`
	Email    string `json:"email"`
	Password []byte `json:"password"`
}

func (q *Queries) GetUserAuth(ctx context.Context, email string) (*GetUserAuthRow, error) {
	row := q.db.QueryRow(ctx, getUserAuth, email)
	var i GetUserAuthRow
	err := row.Scan(&i.ID, &i.Email, &i.Password)
	return &i, err
}

const hardDeleteUser = `-- name: HardDeleteUser :execrows
DELETE FROM users
 WHERE id = $1
`

func (q *Queries) HardDeleteUser(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.Exec(ctx, hardDeleteUser, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updatePassword = `-- name: UpdatePassword :execrows
UPDATE users
   SET password = $1,
       password_updated_at = CURRENT_TIMESTAMP
 WHERE id = $2
   AND deleted_at IS NULL
`

type UpdatePasswordParams struct {
	Password []byte `json:"password"`
	ID       int32  `json:"id"`
}

func (q *Queries) UpdatePassword(ctx context.Context, arg *UpdatePasswordParams) (int64, error) {
	result, err := q.db.Exec(ctx, updatePassword, arg.Password, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
