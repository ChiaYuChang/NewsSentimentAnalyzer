// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: endpoints.sql

package model

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEndpoint = `-- name: CreateEndpoint :one
INSERT INTO endpoints (
    name, api_id, template_name
) VALUES (
    $1, $2, $3
)
RETURNING id
`

type CreateEndpointParams struct {
	Name         string `json:"name"`
	ApiID        int16  `json:"api_id"`
	TemplateName string `json:"template_name"`
}

func (q *Queries) CreateEndpoint(ctx context.Context, arg *CreateEndpointParams) (int32, error) {
	row := q.db.QueryRow(ctx, createEndpoint, arg.Name, arg.ApiID, arg.TemplateName)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteEndpoint = `-- name: DeleteEndpoint :execrows
DELETE FROM endpoints
 WHERE id = $1
`

func (q *Queries) DeleteEndpoint(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.Exec(ctx, deleteEndpoint, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const listEndpointByAPIID = `-- name: ListEndpointByAPIID :many
SELECT name, api_id, template_name
  FROM endpoints
 WHERE api_id = ANY($1::int[]) 
   AND deleted_at IS NULL
`

type ListEndpointByAPIIDRow struct {
	Name         string `json:"name"`
	ApiID        int16  `json:"api_id"`
	TemplateName string `json:"template_name"`
}

func (q *Queries) ListEndpointByAPIID(ctx context.Context, apiID []int32) ([]*ListEndpointByAPIIDRow, error) {
	rows, err := q.db.Query(ctx, listEndpointByAPIID, apiID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListEndpointByAPIIDRow
	for rows.Next() {
		var i ListEndpointByAPIIDRow
		if err := rows.Scan(&i.Name, &i.ApiID, &i.TemplateName); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEndpointByOwner = `-- name: ListEndpointByOwner :many
SELECT ep.id AS endpoint_id,ep.name AS endpoint_name, ep.api_id, ep.template_name, 
       ak.key, a.name AS api_name, a.type, a.icon, a.image, a.document_url
  FROM endpoints AS ep
  INNER JOIN apikeys AS ak
    ON ep.api_id = ak.api_id
  INNER JOIN apis AS a
    ON ep.api_id = a.id
  WHERE ak.owner = $1
    AND ep.deleted_at IS NULL
    AND ak.deleted_at IS NULL
    AND a.deleted_at IS NULL
    AND a.type = 'source'
  ORDER BY a.name, ep.id
`

type ListEndpointByOwnerRow struct {
	EndpointID   int32       `json:"endpoint_id"`
	EndpointName string      `json:"endpoint_name"`
	ApiID        int16       `json:"api_id"`
	TemplateName string      `json:"template_name"`
	Key          string      `json:"key"`
	ApiName      string      `json:"api_name"`
	Type         ApiType     `json:"type"`
	Icon         pgtype.Text `json:"icon"`
	Image        pgtype.Text `json:"image"`
	DocumentUrl  string      `json:"document_url"`
}

func (q *Queries) ListEndpointByOwner(ctx context.Context, owner int32) ([]*ListEndpointByOwnerRow, error) {
	rows, err := q.db.Query(ctx, listEndpointByOwner, owner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListEndpointByOwnerRow
	for rows.Next() {
		var i ListEndpointByOwnerRow
		if err := rows.Scan(
			&i.EndpointID,
			&i.EndpointName,
			&i.ApiID,
			&i.TemplateName,
			&i.Key,
			&i.ApiName,
			&i.Type,
			&i.Icon,
			&i.Image,
			&i.DocumentUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
