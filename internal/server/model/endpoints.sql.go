// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: endpoints.sql

package model

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countEndpoint = `-- name: CountEndpoint :one
SELECT count(*) FROM endpoints
`

func (q *Queries) CountEndpoint(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countEndpoint)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEndpoint = `-- name: CreateEndpoint :one
INSERT INTO endpoints (
    name, api_id, template_name
) VALUES (
    $1, $2, $3
)
RETURNING id
`

type CreateEndpointParams struct {
	Name         string `json:"name"`
	ApiID        int16  `json:"api_id"`
	TemplateName string `json:"template_name"`
}

func (q *Queries) CreateEndpoint(ctx context.Context, arg *CreateEndpointParams) (int32, error) {
	row := q.db.QueryRow(ctx, createEndpoint, arg.Name, arg.ApiID, arg.TemplateName)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteEndpoint = `-- name: DeleteEndpoint :execrows
DELETE FROM endpoints
 WHERE id = $1
`

func (q *Queries) DeleteEndpoint(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.Exec(ctx, deleteEndpoint, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const listAllEndpoint = `-- name: ListAllEndpoint :many
SELECT e.id AS endpoint_id, e.name AS endpoint_name, e.api_id, 
       a.name AS api_name, e.template_name
  FROM endpoints AS e
 INNER JOIN apis AS a
    ON e.api_id = a.id
 WHERE e.id > $2
   AND e.deleted_at IS NULL
   AND a.deleted_at IS NULL
 ORDER BY e.api_id, e.name
 LIMIT $1
`

type ListAllEndpointParams struct {
	Limit int32 `json:"limit"`
	Next  int32 `json:"next"`
}

type ListAllEndpointRow struct {
	EndpointID   int32  `json:"endpoint_id"`
	EndpointName string `json:"endpoint_name"`
	ApiID        int16  `json:"api_id"`
	ApiName      string `json:"api_name"`
	TemplateName string `json:"template_name"`
}

func (q *Queries) ListAllEndpoint(ctx context.Context, arg *ListAllEndpointParams) ([]*ListAllEndpointRow, error) {
	rows, err := q.db.Query(ctx, listAllEndpoint, arg.Limit, arg.Next)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListAllEndpointRow
	for rows.Next() {
		var i ListAllEndpointRow
		if err := rows.Scan(
			&i.EndpointID,
			&i.EndpointName,
			&i.ApiID,
			&i.ApiName,
			&i.TemplateName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEndpointByOwner = `-- name: ListEndpointByOwner :many
SELECT ep.id AS endpoint_id,ep.name AS endpoint_name, ep.api_id, ep.template_name, 
       ak.key, a.name AS api_name, a.type, a.icon, a.image, a.document_url
  FROM endpoints AS ep
  INNER JOIN apikeys AS ak
    ON ep.api_id = ak.api_id
  INNER JOIN apis AS a
    ON ep.api_id = a.id
  WHERE ak.owner = $1
    AND ep.deleted_at IS NULL
    AND ak.deleted_at IS NULL
    AND a.deleted_at IS NULL
    AND a.type = 'source'
  ORDER BY a.name, ep.id
`

type ListEndpointByOwnerRow struct {
	EndpointID   int32       `json:"endpoint_id"`
	EndpointName string      `json:"endpoint_name"`
	ApiID        int16       `json:"api_id"`
	TemplateName string      `json:"template_name"`
	Key          string      `json:"key"`
	ApiName      string      `json:"api_name"`
	Type         ApiType     `json:"type"`
	Icon         pgtype.Text `json:"icon"`
	Image        pgtype.Text `json:"image"`
	DocumentUrl  string      `json:"document_url"`
}

func (q *Queries) ListEndpointByOwner(ctx context.Context, owner int32) ([]*ListEndpointByOwnerRow, error) {
	rows, err := q.db.Query(ctx, listEndpointByOwner, owner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListEndpointByOwnerRow
	for rows.Next() {
		var i ListEndpointByOwnerRow
		if err := rows.Scan(
			&i.EndpointID,
			&i.EndpointName,
			&i.ApiID,
			&i.TemplateName,
			&i.Key,
			&i.ApiName,
			&i.Type,
			&i.Icon,
			&i.Image,
			&i.DocumentUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
