// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.0
// source: jobs.sql

package model

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const cleanUpJobs = `-- name: CleanUpJobs :execrows
DELETE FROM jobs
 WHERE deleted_at IS NOT NULL
`

func (q *Queries) CleanUpJobs(ctx context.Context) (int64, error) {
	result, err := q.db.Exec(ctx, cleanUpJobs)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const createJob = `-- name: CreateJob :one
INSERT INTO jobs (
  owner, status, src_api_id, src_query, llm_api_id, llm_query
) VALUES (
    $1, $2, $3, $4, $5, $6
) 
RETURNING id
`

type CreateJobParams struct {
	Owner    uuid.UUID `json:"owner"`
	Status   JobStatus `json:"status"`
	SrcApiID int16     `json:"src_api_id"`
	SrcQuery string    `json:"src_query"`
	LlmApiID int16     `json:"llm_api_id"`
	LlmQuery []byte    `json:"llm_query"`
}

func (q *Queries) CreateJob(ctx context.Context, arg *CreateJobParams) (int32, error) {
	row := q.db.QueryRow(ctx, createJob,
		arg.Owner,
		arg.Status,
		arg.SrcApiID,
		arg.SrcQuery,
		arg.LlmApiID,
		arg.LlmQuery,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteJob = `-- name: DeleteJob :execrows
UPDATE jobs
   SET deleted_at = CURRENT_TIMESTAMP
 WHERE id = $1
   AND owner = $2
`

type DeleteJobParams struct {
	ID    int32     `json:"id"`
	Owner uuid.UUID `json:"owner"`
}

func (q *Queries) DeleteJob(ctx context.Context, arg *DeleteJobParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteJob, arg.ID, arg.Owner)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getJobsByJobId = `-- name: GetJobsByJobId :one
SELECT j.id, j.owner, j.status, asrc.name AS news_src, allm.name AS analyzer, j.created_at, j.updated_at
  FROM jobs AS j
 INNER JOIN apis AS asrc ON j.src_api_id = asrc.id
 INNER JOIN apis AS allm ON j.llm_api_id = allm.id 
 WHERE j.owner = $1
   AND j.id = $2
   AND j.deleted_at IS NULL
`

type GetJobsByJobIdParams struct {
	Owner uuid.UUID `json:"owner"`
	ID    int32     `json:"id"`
}

type GetJobsByJobIdRow struct {
	ID        int32              `json:"id"`
	Owner     uuid.UUID          `json:"owner"`
	Status    JobStatus          `json:"status"`
	NewsSrc   string             `json:"news_src"`
	Analyzer  string             `json:"analyzer"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetJobsByJobId(ctx context.Context, arg *GetJobsByJobIdParams) (*GetJobsByJobIdRow, error) {
	row := q.db.QueryRow(ctx, getJobsByJobId, arg.Owner, arg.ID)
	var i GetJobsByJobIdRow
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Status,
		&i.NewsSrc,
		&i.Analyzer,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getJobsByOwner = `-- name: GetJobsByOwner :many
SELECT j.id, j.owner, j.status, asrc.name AS news_src, allm.name AS analyzer, j.created_at, j.updated_at
  FROM jobs AS j
 INNER JOIN apis AS asrc ON j.src_api_id = asrc.id
 INNER JOIN apis AS allm ON j.llm_api_id = allm.id 
 WHERE j.owner = $1
   AND j.id > $2::int
   AND j.deleted_at IS NULL
 ORDER BY 
       j.updated_at DESC,
       j.status     DESC
 LIMIT $3::int
`

type GetJobsByOwnerParams struct {
	Owner uuid.UUID `json:"owner"`
	Next  int32     `json:"next"`
	N     int32     `json:"n"`
}

type GetJobsByOwnerRow struct {
	ID        int32              `json:"id"`
	Owner     uuid.UUID          `json:"owner"`
	Status    JobStatus          `json:"status"`
	NewsSrc   string             `json:"news_src"`
	Analyzer  string             `json:"analyzer"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetJobsByOwner(ctx context.Context, arg *GetJobsByOwnerParams) ([]*GetJobsByOwnerRow, error) {
	rows, err := q.db.Query(ctx, getJobsByOwner, arg.Owner, arg.Next, arg.N)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetJobsByOwnerRow
	for rows.Next() {
		var i GetJobsByOwnerRow
		if err := rows.Scan(
			&i.ID,
			&i.Owner,
			&i.Status,
			&i.NewsSrc,
			&i.Analyzer,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateJobStatus = `-- name: UpdateJobStatus :execrows
UPDATE jobs
   SET status = $1,
       updated_at = CURRENT_TIMESTAMP
 WHERE id = $2
   AND owner = $3
   AND deleted_at IS NULL
`

type UpdateJobStatusParams struct {
	Status JobStatus `json:"status"`
	ID     int32     `json:"id"`
	Owner  uuid.UUID `json:"owner"`
}

func (q *Queries) UpdateJobStatus(ctx context.Context, arg *UpdateJobStatusParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateJobStatus, arg.Status, arg.ID, arg.Owner)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
